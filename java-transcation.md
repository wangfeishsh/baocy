参考：http:\/\/www.infoq.com\/cn\/minibooks\/JTDS

X\/Open XA 接口规范 :http:\/\/pubs.opengroup.org\/onlinepubs\/009680699\/toc.pdf

Java 中有三种可以 的事务模型,分别称作本地事务模型\(Local Transaction Model\),编程式事务模型 \(Programmatic Transaction Model\),和声明式事务模型\(Declarative Transaction Model\)。虽 然,在随后的章节将分别深入讲解,我想在这里还是有必要将它们分别概述一下。

所谓“本地事务模型”,得名于事实上不是编程框架本身来管理事务,事务是交给本地资源管 理器\(local resource manager\)来管理的。资源管理器是用于通信的、事实上的数据源\(data source\)提供者。举例来说,对于数据库,资源管理器是通过数据库驱动和数据库管理系统 \(Database Management System,DBMS\)来实现的。对于 JMS,所谓资源管理器就是通过特 定的 JMS 提供者\(provider\)实现的队列\(queue\)或主题\(topic\)的连接工厂\(connection factory\)。经由本地事务模型,开发人员管理的是“连接\(connection\)”,而非 “事务”。DBMS 和 JMS 的提供者真正管理了本地事务。关于“本地事务模型”的细节将在第二章介绍。

“编程式事务模型”利用了 Java 事务 API\(Java Transaction API, JTA\)及其底层事务服务实现的 能量以提供事务支持,突破了“本地事务模型”的种种限制。通过编程式事务模型,开发人员 的编码对象是“事务”,而非“连接”。通过使用 javax.transaction.UserTransation 接口,开发人 员调用 begin\(\)方法开始一个事务,调用 commit\(\)或 rollback\(\)方法去终止这个事务。虽然通 常情况下不鼓励大量使用编程式事务,然而,在客户端发起的,对远程无状态会话 Bean \(Stateless Session Beans\)的 EJB 事务访问的场景下,它还是有可能用到的。我们将在第三 章仔细讨论这种事务模型。

“声明式事务模型”,在 EJB 的世界中也成为容器托管的事务模型\(Container-Managed Transactions\),是本书通篇所主要聚焦的事务模型。在声明式事务模型的环境下,软件框架 或“容器”管理了事务的开始和结束\(或者提交,或者回滚\)。开发人员仅仅需要告诉软件框 架,碰到应用异常时“去回滚事务”即可,对事务的配置都是通过 EJB 中的 XML 部署描述文件 \(例如 ejb-jar.xml\)或 Spring 中的 bean 定义文件\(例如 ApplicationContext.xml\)来完成的。

参考1：

大体上所来，JTA是一种接口规范，定义了一套接口，接口定义了相关的程序角色之间需要遵守的约定，JTA中约定了几种主要的程序角色，分别是事务管理器、事务客户、应用服务器、资源管理器。简单地说来就是，事务客户发起事务，应用服务器根据事物客户的请求决定如何向事务管理器体提交一个事务请求，如新建一个（require new），参与（require）等，事务管理器接收到了应用服务器发出的事务请求，然后事务管理器根据某种特定的协议（一般是两阶段提交协议）和资源管理器通过交换事务上下文来实现事务的功能。在这里，事务客户使用UserTransaction接口，应用服务器使用TransactionManager、Transaction、Synchronization接口，资源管理器实现XAResource接口。

那么JTS呢？JTA和JTS的关系如何呢？上面的内容有提到事务管理器要和资源管理器要进行事务上下文传播的交互，其中应用服务器和事务管理器之间也有传播事务上下文的交互，有时候事务客户和应用服务器也需要传播事务上下文，众所周知，只要涉及到软件交互往往都会有一套规范。那么如何来传递这种事务上下文呢？这就是JTS了。JTS也定义了一套规范，它约定了各个程序角色之间如何传递事务上下文，它源自CORBA 的OTS规范，基于IIOP（一种软件交互协议）。不要认为JTS是JTA的实现，JTA其实就定义了一个空架子，告诉JTA的实现者应该怎样做怎样做，但是具体到做的时候JTS就来插一手了。因为JTA约定的这些角色要进行事务上下文的交互啊，JTS约定了应该怎样去进行交互。

总体上来说JTA更多的是从框架的角度来约定程序角色的接口，而JTS则是从具体实现的角度来约定程序角色之间的接口，两者各司其职。照这样看来，SUN搞出来的这两个名字还真有点艺术感，有点哲学的味道了。

参考2:

**JTA**

JTA定义了一套接口，其中约定了几种主要的角色：TransactionManager、UserTransaction、Transaction、XAResource，并定义了这些角色之间需要遵守的规范，如Transaction的委托给TransactionManager等。

** JTS**

JTS也是一组规范，上面提到JTA中需要角色之间的交互，那应该如何交互？JTS就是约定了交互细节的规范。

总体上来说JTA更多的是从框架的角度来约定程序角色的接口，而JTS则是从具体实现的角度来约定程序角色之间的接口，两者各司其职。

因为JTA相对来说，更高层一些，我们主要关注JTA。

** XA**

XA协议，规定事务管理器和资源管理器接口，采用二阶段提交协议。

** 源码**

规范的接口位于javax.transaction：

![](http://img.blog.csdn.net/20140810110328712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlkYXRnYg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

......

事务隔离级别的现实

另一个对开发人员可用的事务设置是事务的隔离级别。**事务隔离\(Transaction Isolation\)是 指交织在一起发生的事务之间相互影响的程度。它决定了在其他事务访问和更新同一份数据时,一个事务对更新所允许的可见程度。**关系数据库系统\(DBMS\),EJB,Spring 都允许设定事务隔离级别。然而,这样的设置,是**数据库和应用服务器实现相依赖的**。应用服务器可能支持多种隔离级别,但对应的数据库必须支持这些同样的隔离级别,这些设置才可能真正生效。

事务隔离同时是数据库并发度\(concurrency\)和一致性\(consistency\)的函数。当我们提高了事务隔离度,我们实际上降低了数据库并发程度,但提高了一致性。

......

该设置能直接影响应用的性能和数据完整性。例如,对于高性能的应用,诸如信用卡处理程 序,您可以通过降低隔离级别以提高并发度\(但这样会损害数据完整性\)。对低并发、需要 高度数据完整性的金融类应用,您需要提高隔离以别,以增强整体数据一致性\(但损害了性 能\)。大多数应用服务器和数据库都具有平衡并发度和一致性的一个默认设置值。然而,在 EJB 和 Spring 中,您能够通过更改相关设置在需要的时候优化应用。

EJB 和 Spring 均支持四种主要的隔离级别,这些设置\(隔离度从低到高\)分别是:

 TransactionReadUncommitted 读取未提交

 TransactionReadCommitted 读取已提交

 TransactionRepeatableRead 可重复读

 TransactionSerializable 可序列化

**TransactionReadUncommitted**

这是 EJB 和 Spring 皆支持的最低隔离度设置。这一隔离级别允许事务读取其他事务在提交到 数据库之前产生的未提交更改。为了展示这一隔离级别是如何工作的,我们假设当前一笔特 定的股票交易,在每股 90 美金时进行。两个事务\(事务 A 和事务 B\)试图同时访问同一数 据,事务 A 进行更新操作,而事务 B 进行读取操作。下图展示了在设置 TransactionReadUncommitted 时两个事务是如何交互的:

![](/assets/1.png)

注意,在图示中,事务 A 于时间点 t2 对数据库进行了一次更新,而事务 B 能够在时间点 t3 读取这一数据,读取的时候该数据的修改是并未被提交进数据库的。如图所示,事务 A 做 出的修改无法与事务 B 相隔离。如果事务 A 回滚了这一修改,事务 B 读取到的数据极有可 能是错误的。这一隔离级别设置违反了基本的 ACID 准则,很多数据库厂商并不支持这一隔 离级别\(包括 Oracle\)。

**TransactionReadCommitted**

该隔离级别设置允许多个事务访问同一份数据,但将未提交的数据对其他事务隐藏,直至数 据提交。同样使用上面的例子,假设当前以 90 美金的价格交易股票,两笔事务\(事务 A 和 事务 B\)试图在同一时间访问同一数据,事务 A 做更新而事务 B 做读取。下图展示了在设置 TransactionReadCommitted 时两个事务是如何交互的:

![](/assets/2.png)

注意,当事务 A 在时间点 t2 更改了数据,事务 B 在时间点 t3 的读取操作中并未能看到这一 修改。这是一个非常好的隔离设置;它允许事务 B 访问数据\(支持并发\),并同时隐藏了其 他事务对同一份数据的未提交更改,直至更改提交。这是大多数数据库缺省的隔离设定,很 多数据库厂商都支持它。

**TransactionRepeatableRead**

和以上让事务交错发生的策略不同,这个隔离级别保持了事务彼此隔绝。这一隔离级别保证, 一旦在某一事务中读取了数据库的一个值集,在后续的每次查询操作中都读到同样的值\(除 非此事务拿到这些数据的读写锁,并自行更改了数据\)。为了演示这个隔离级别,我们假设 有一个 select 语句查询数据库,以获取今天迄今为止买入的所有股票。事务 A 在主管查询的 事务 B 的进行过程中插入了一些数据。下图展示了在设置为 TransactionRepeatableRead 隔离 级别时事务间是如何交互的:

![](/assets/3.png)

注意在这个例子中,虽然事务 B 的执行过程中购入了一支新的股票,事务 B 却自始至终返 回同样的查询结果,不论其他事务的最新提交结果如何。仅当事务 B 提交了之后,它才能够 看到最近购入的那一笔股票。请注意在这样的隔离设置下,目标数据在被查询和更改时被同 时加上读锁和写锁,使用这一隔离级别应该小心,因为在 Repeatable Read 隔离级别下,一 个事务如果要更改数据,而这一数据被其他事务读取时,此事务需要等待占用数据事务提交 的操作\(或直接返回失败\)。

**TransactionSerializable**

这是 Java 所能支持的最低的事务隔离级别。在这一隔离级别设置下,交错发生的事务被“堆 迭”起来,以致同一时间点仅仅有一个事务具备访问目标数据的权力\(我们在本节随后的部 分可以看到,这在 Oracle 数据库不完全是成立的\)。如果使用这一设置,并发度将会收到非 常大的影响,但数据一致性将会得到极大提高。使用上面同样的例子,假设当前以 90 美金 的价格交易股票,两笔事务\(事务 A 和事务 B\)试图在同一时间访问同一数据,事务 A 做更 新而事务 B 做读取。下图展示了在设置 TransactionSerializable 时两个事务是如何交互的:

![](/assets/4.png)

注意事务 B 将一直挂起,直到事务 A 完成。虽然所有的数据库厂商都支持这一设置选项, Oracle 处理该设置稍有不同。由于 Oracle 使用数据版本\(data versioning\)技术,它实际上 并不真正挂起事务 B。反之,如果在事务 B 的进行过程中,事务 B 试图访问目标数据,Oracle 将抛出 ORA-08177 错误,指出对该事务无法序列化访问数据。

......

**XA **接口详解

X\/Open XA 接口是双向的系统接口,在事务管理器\(Transaction Manager\)以及一个或多个资源管理器\(Resource Manager\)之间形成通信桥梁。事务管理器控制着 JTA 事务,管理事务生命周期,并协调资源。在 JTA 中,事务管理器抽象为 javax.transaction.TransactionManager 接口,并通过底层事务服务\(即 JTS\)实现。资源管理器负责控制和管理实际资源\(如数据库或 JMS 队列\)。下图说明了事务管理器、资源管理器,以及典型 JTA 环境中客户端应用之间的关系:

![](/assets/5.png)

两阶段提交协议\(The two-phase commit protocol,2PC\)是 XA 用于在全局事务中协调多个 资源的机制。

......

经验异常 **\***\(**Heuristic Exception**\)处理

_\* 有关 Heuristic Exception 的翻译,Heuristic 在大多数计算机书籍中被翻译为“启发式”,指 根据掌握的有限事实,容易“诱导”出来的大概规律和判断,这样的规律和判断不一定是经过 严格证明或验证的,或缺乏严格验证的可能性。在哲学领域,其根本含义是“经验\(主义\) 的”,如我们常常看到的“经验算法”,“经验公式”等。显然,在 Java 事务处理,两阶段提交 的这个语境下,Heuristic 并不是所谓“启发式”的含义。在这里,一定程度上的具体解释是, 在两阶段提交的第一阶段,事务管理器接受到了所协调资源的状态,获得了对全局事务处理 状态的一定“认知”,但在随后的处理中,由于种种原因,被协调的资源无法兑现之前的\(提 交\)承诺,于是这种既有的“认知”就发生问题了,造成了 Heuristic Exception——因此,个人 认为,将它翻译为“经验异常”比较准确。_

在两阶段提交的过程,资源管理器可能会使用“经验化决策”的策略,或者提交,或者回滚它 自己的工作,而不受事务管理器的控制。“经验化决策”是指根据多种内部和外部因素做出智 能决定的过程。当资源管理器这么做了,它会向客户端报上一个经验异常\(Heuristic Exception\)。

所幸的是,经验异常并不是特别常见。它仅仅发生在 XA 环境下,做两阶段提交的过程中, 特别是事务参与者在第一阶段产生了响应之后。经验异常最常见的原因是第一阶段和第二阶 段之间的超时情况。当通讯延迟或丢失,资源管理器或许要做出提交或回滚其工作的决定, 以释放资源。不出意料,经验异常发生最频繁的时候正是高资源利用时间段。当您在应用中 发现经验异常时,您应该查找是否有事务超时问题,资源锁定问题,以及资源使用过量问题, 这些问题常常是经验异常的根本原因。偶尔网络延迟或网络故障也会导致经验异常。同样的, 如上面的章节所述,使用“最后参与者支持”特性会导致经验异常更为频繁的发生。

JTA 暴露出的三种 JTA 经验异常为 HeuristicRollbackException,HeuristicCommitException,以 及 HeuristicMixedException。我们分别用下面的场景说明之:

场景 **1**:在 **commit **操作阶段的 **HeuristicRollbackException **异常

在此场景中,客户端在 XA 环境下执行更新操作,向事务管理器发起提交当前事务的请求。 事务管理器开启两阶段提交流程的第一阶段,随即轮询资源管理器。所有资源管理器向事务 管理器报告说它们已经做好了提交事务的准备。然而,在\(两阶段提交流程的\)第一阶段和 第二阶段之间每个资源管理器独立的做出了回滚它们已完成工作的经验性决定。当进入第二 阶段,提交请求被发送到资源管理器时,因为所做的工作已经在此之前回滚了,事务管理器 将会向调用者报告 HeuristicRollbackException 异常。

当接受到此类异常时,常用的正确处理方式是将此异常传回客户端,让客户端重新提交请求。 我们不能简单的再次调用 commit 请求,因为对数据库产生的更新已经随回滚操作从数据库 事务日志中删除了。下面的序列图说明了这一场景:

```
第一步:第一阶段处理(准备阶段)

```

