参考：http:\/\/www.infoq.com\/cn\/minibooks\/JTDS

X\/Open XA 接口规范 :http:\/\/pubs.opengroup.org\/onlinepubs\/009680699\/toc.pdf



事务隔离级别的现实

另一个对开发人员可用的事务设置是事务的隔离级别。**事务隔离\(Transaction Isolation\)是 指交织在一起发生的事务之间相互影响的程度。它决定了在其他事务访问和更新同一份数据时,一个事务对更新所允许的可见程度。**关系数据库系统\(DBMS\),EJB,Spring 都允许设定事务隔离级别。然而,这样的设置,是**数据库和应用服务器实现相依赖的**。应用服务器可能支持多种隔离级别,但对应的数据库必须支持这些同样的隔离级别,这些设置才可能真正生效。

事务隔离同时是数据库并发度\(concurrency\)和一致性\(consistency\)的函数。当我们提高了事务隔离度,我们实际上降低了数据库并发程度,但提高了一致性。

......

该设置能直接影响应用的性能和数据完整性。例如,对于高性能的应用,诸如信用卡处理程 序,您可以通过降低隔离级别以提高并发度\(但这样会损害数据完整性\)。对低并发、需要 高度数据完整性的金融类应用,您需要提高隔离以别,以增强整体数据一致性\(但损害了性 能\)。大多数应用服务器和数据库都具有平衡并发度和一致性的一个默认设置值。然而,在 EJB 和 Spring 中,您能够通过更改相关设置在需要的时候优化应用。

EJB 和 Spring 均支持四种主要的隔离级别,这些设置\(隔离度从低到高\)分别是:

 TransactionReadUncommitted 读取未提交

 TransactionReadCommitted 读取已提交

 TransactionRepeatableRead 可重复读

 TransactionSerializable 可序列化

**TransactionReadUncommitted**

这是 EJB 和 Spring 皆支持的最低隔离度设置。这一隔离级别允许事务读取其他事务在提交到 数据库之前产生的未提交更改。为了展示这一隔离级别是如何工作的,我们假设当前一笔特 定的股票交易,在每股 90 美金时进行。两个事务\(事务 A 和事务 B\)试图同时访问同一数 据,事务 A 进行更新操作,而事务 B 进行读取操作。下图展示了在设置 TransactionReadUncommitted 时两个事务是如何交互的:

![](/assets/1.png)

注意,在图示中,事务 A 于时间点 t2 对数据库进行了一次更新,而事务 B 能够在时间点 t3 读取这一数据,读取的时候该数据的修改是并未被提交进数据库的。如图所示,事务 A 做 出的修改无法与事务 B 相隔离。如果事务 A 回滚了这一修改,事务 B 读取到的数据极有可 能是错误的。这一隔离级别设置违反了基本的 ACID 准则,很多数据库厂商并不支持这一隔 离级别\(包括 Oracle\)。

**TransactionReadCommitted**

该隔离级别设置允许多个事务访问同一份数据,但将未提交的数据对其他事务隐藏,直至数 据提交。同样使用上面的例子,假设当前以 90 美金的价格交易股票,两笔事务\(事务 A 和 事务 B\)试图在同一时间访问同一数据,事务 A 做更新而事务 B 做读取。下图展示了在设置 TransactionReadCommitted 时两个事务是如何交互的:

![](/assets/2.png)

注意,当事务 A 在时间点 t2 更改了数据,事务 B 在时间点 t3 的读取操作中并未能看到这一 修改。这是一个非常好的隔离设置;它允许事务 B 访问数据\(支持并发\),并同时隐藏了其 他事务对同一份数据的未提交更改,直至更改提交。这是大多数数据库缺省的隔离设定,很 多数据库厂商都支持它。

**TransactionRepeatableRead**

和以上让事务交错发生的策略不同,这个隔离级别保持了事务彼此隔绝。这一隔离级别保证, 一旦在某一事务中读取了数据库的一个值集,在后续的每次查询操作中都读到同样的值\(除 非此事务拿到这些数据的读写锁,并自行更改了数据\)。为了演示这个隔离级别,我们假设 有一个 select 语句查询数据库,以获取今天迄今为止买入的所有股票。事务 A 在主管查询的 事务 B 的进行过程中插入了一些数据。下图展示了在设置为 TransactionRepeatableRead 隔离 级别时事务间是如何交互的:

![](/assets/3.png)

注意在这个例子中,虽然事务 B 的执行过程中购入了一支新的股票,事务 B 却自始至终返 回同样的查询结果,不论其他事务的最新提交结果如何。仅当事务 B 提交了之后,它才能够 看到最近购入的那一笔股票。请注意在这样的隔离设置下,目标数据在被查询和更改时被同 时加上读锁和写锁,使用这一隔离级别应该小心,因为在 Repeatable Read 隔离级别下,一 个事务如果要更改数据,而这一数据被其他事务读取时,此事务需要等待占用数据事务提交 的操作\(或直接返回失败\)。

**TransactionSerializable**

这是 Java 所能支持的最低的事务隔离级别。在这一隔离级别设置下,交错发生的事务被“堆 迭”起来,以致同一时间点仅仅有一个事务具备访问目标数据的权力\(我们在本节随后的部 分可以看到,这在 Oracle 数据库不完全是成立的\)。如果使用这一设置,并发度将会收到非 常大的影响,但数据一致性将会得到极大提高。使用上面同样的例子,假设当前以 90 美金 的价格交易股票,两笔事务\(事务 A 和事务 B\)试图在同一时间访问同一数据,事务 A 做更 新而事务 B 做读取。下图展示了在设置 TransactionSerializable 时两个事务是如何交互的:

![](/assets/4.png)

注意事务 B 将一直挂起,直到事务 A 完成。虽然所有的数据库厂商都支持这一设置选项, Oracle 处理该设置稍有不同。由于 Oracle 使用数据版本\(data versioning\)技术,它实际上 并不真正挂起事务 B。反之,如果在事务 B 的进行过程中,事务 B 试图访问目标数据,Oracle 将抛出 ORA-08177 错误,指出对该事务无法序列化访问数据。

......

**XA **接口详解

X\/Open XA 接口是双向的系统接口,在事务管理器\(Transaction Manager\)以及一个或多个资源管理器\(Resource Manager\)之间形成通信桥梁。事务管理器控制着 JTA 事务,管理事务生命周期,并协调资源。在 JTA 中,事务管理器抽象为 javax.transaction.TransactionManager 接口,并通过底层事务服务\(即 JTS\)实现。资源管理器负责控制和管理实际资源\(如数据库或 JMS 队列\)。下图说明了事务管理器、资源管理器,以及典型 JTA 环境中客户端应用之间的关系:

![](/assets/5.png)

两阶段提交协议\(The two-phase commit protocol,2PC\)是 XA 用于在全局事务中协调多个 资源的机制。

......

经验异常 **\***\(**Heuristic Exception**\)处理

_\* 有关 Heuristic Exception 的翻译,Heuristic 在大多数计算机书籍中被翻译为“启发式”,指 根据掌握的有限事实,容易“诱导”出来的大概规律和判断,这样的规律和判断不一定是经过 严格证明或验证的,或缺乏严格验证的可能性。在哲学领域,其根本含义是“经验\(主义\) 的”,如我们常常看到的“经验算法”,“经验公式”等。显然,在 Java 事务处理,两阶段提交 的这个语境下,Heuristic 并不是所谓“启发式”的含义。在这里,一定程度上的具体解释是, 在两阶段提交的第一阶段,事务管理器接受到了所协调资源的状态,获得了对全局事务处理 状态的一定“认知”,但在随后的处理中,由于种种原因,被协调的资源无法兑现之前的\(提 交\)承诺,于是这种既有的“认知”就发生问题了,造成了 Heuristic Exception——因此,个人 认为,将它翻译为“经验异常”比较准确。_

在两阶段提交的过程,资源管理器可能会使用“经验化决策”的策略,或者提交,或者回滚它 自己的工作,而不受事务管理器的控制。“经验化决策”是指根据多种内部和外部因素做出智 能决定的过程。当资源管理器这么做了,它会向客户端报上一个经验异常\(Heuristic Exception\)。

所幸的是,经验异常并不是特别常见。它仅仅发生在 XA 环境下,做两阶段提交的过程中, 特别是事务参与者在第一阶段产生了响应之后。经验异常最常见的原因是第一阶段和第二阶 段之间的超时情况。当通讯延迟或丢失,资源管理器或许要做出提交或回滚其工作的决定, 以释放资源。不出意料,经验异常发生最频繁的时候正是高资源利用时间段。当您在应用中 发现经验异常时,您应该查找是否有事务超时问题,资源锁定问题,以及资源使用过量问题, 这些问题常常是经验异常的根本原因。偶尔网络延迟或网络故障也会导致经验异常。同样的, 如上面的章节所述,使用“最后参与者支持”特性会导致经验异常更为频繁的发生。

JTA 暴露出的三种 JTA 经验异常为 HeuristicRollbackException,HeuristicCommitException,以 及 HeuristicMixedException。我们分别用下面的场景说明之:

场景 **1**:在 **commit **操作阶段的 **HeuristicRollbackException **异常

在此场景中,客户端在 XA 环境下执行更新操作,向事务管理器发起提交当前事务的请求。 事务管理器开启两阶段提交流程的第一阶段,随即轮询资源管理器。所有资源管理器向事务 管理器报告说它们已经做好了提交事务的准备。然而,在\(两阶段提交流程的\)第一阶段和 第二阶段之间每个资源管理器独立的做出了回滚它们已完成工作的经验性决定。当进入第二 阶段,提交请求被发送到资源管理器时,因为所做的工作已经在此之前回滚了,事务管理器 将会向调用者报告 HeuristicRollbackException 异常。

当接受到此类异常时,常用的正确处理方式是将此异常传回客户端,让客户端重新提交请求。 我们不能简单的再次调用 commit 请求,因为对数据库产生的更新已经随回滚操作从数据库 事务日志中删除了。下面的序列图说明了这一场景:

```
第一步:第一阶段处理(准备阶段)

第二步:在第一阶段和第二阶段之间 

第三步:第二阶段处理(提交阶段) 

```

场景 **2**:在 **commit **操作阶段的 **HeuristicMixedException **异常

在此场景中,客户端在 XA 环境下执行更新操作,向事务管理器发起提交当前事务的请求。 事务管理器开启两阶段提交流程的第一阶段,随即轮询资源管理器。所有资源管理器向事务 管理器报告说它们已经做好了提交事务的准备。和第一种场景不同的是,在第一阶段和第二 阶段发生的间隙,有资源管理器\(例如消息队列\)做出了经验性的决定提交其工作,而其他 资源管理器\(例如数据库\)做出了回滚的经验性决定。在这种情况下,事务管理器向调用者 报告 HeuristicMixedException 异常。

这种情况下,非常难于选择正确的后续应对方式,因为我们不知道哪些资源提交了工作,哪 些资源回滚了工作。所有目标资源因此处于一种不一致的状态。因为资源管理器彼此互不干 预的独立操作,就经验性决定而言,他们之间没有任何协调和通信。解决这一异常通常需要 人力介入。下面的序列图说明了这一场景:

