参考：http:\/\/www.infoq.com\/cn\/minibooks\/JTDS

Java 中有三种可以 的事务模型,分别称作本地事务模型\(Local Transaction Model\),编程式事务模型 \(Programmatic Transaction Model\),和声明式事务模型\(Declarative Transaction Model\)。虽 然,在随后的章节将分别深入讲解,我想在这里还是有必要将它们分别概述一下。

所谓“本地事务模型”,得名于**事实上不是编程框架本身来管理事务,事务是交给本地资源管 理器\(local resource manager\)来管理的**。资源管理器是用于通信的、事实上的数据源\(data source\)提供者。举例来说,对于数据库,资源管理器是通过数据库驱动和数据库管理系统 \(Database Management System,DBMS\)来实现的。对于 JMS,所谓资源管理器就是通过特 定的 JMS 提供者\(provider\)实现的队列\(queue\)或主题\(topic\)的连接工厂\(connection factory\)。经由本地事务模型,开发人员管理的是“连接\(connection\)”,而非 “事务”。DBMS 和 JMS 的提供者真正管理了本地事务。关于“本地事务模型”的细节将在第二章介绍。

“编程式事务模型”**利用了 Java 事务 API\(Java Transaction API, JTA\)及其底层事务服务实现的 能量以提供事务支持,突破了“本地事务模型”的种种限制**。通过编程式事务模型,开发人员 的编码对象是“事务”,而非“连接”。通过使用 javax.transaction.UserTransation 接口,开发人 员调用 begin\(\)方法开始一个事务,调用 commit\(\)或 rollback\(\)方法去终止这个事务。虽然通 常情况下不鼓励大量使用编程式事务,然而,在客户端发起的,对远程无状态会话 Bean \(Stateless Session Beans\)的 EJB 事务访问的场景下,它还是有可能用到的。我们将在第三 章仔细讨论这种事务模型。

“声明式事务模型”,在 EJB 的世界中也成为**容器托管的事务模型\(Container-Managed Transactions\)**,是本书通篇所主要聚焦的事务模型。在声明式事务模型的环境下,软件框架 或“容器”管理了事务的开始和结束\(或者提交,或者回滚\)。开发人员仅仅需要告诉软件框架,碰到应用异常时“去回滚事务”即可,对事务的配置都是通过 EJB 中的 XML 部署描述文件 \(例如 ejb-jar.xml\)或 Spring 中的 bean 定义文件\(例如 ApplicationContext.xml\)来完成的。 有关“声明式事务模型”的细节将在本书第四章讨论。



ACID 是描述有关事 务的期望特性的字首缩写,这些特性分别是原子性\(Atomicity\),一致性\(Consistency\),独 立性\(Isolation\),和持久性\(Durability\)。

“原子性”的含义是,一个事务必须将它产生的所有更改作为一个单独的工作单元提交,或 者回滚。无论在本次事务中产生了多少数量的更改,所有的更改需被当作一个整体处理。原 子特性有时被称作逻辑工作单元\(LUW,Logical Unit of Work\)特性,或称单一工作单元\(SUW, Single Unit of Work\)特性。

“一致性”的含义是,在活动事务的处理过程中,数据库必须时刻要避免被置于不一致 \(inconsistent\)的状态。这意味着在事务期间,每次对数据库实施的插入、更新或删除操作 时,数据库的完整性约束\(integrity constraints\)都要得到保证——即使在事务还未被提交时 也必须如此。这个特性对开发人员带来了影响。例如,一致性原则隐式地表明,在事务处理 的过程中,您不能在未添加主表记录\(summary record\)的情况下,先去添加从表记录\(detail record\)。虽然某些数据库允许将约束检查延迟到提交时进行,一般而言,您不能在事务处 理期间破坏外关键字限制,即使您打算随后修正它也不行。

“独立性”指的是各个独立事务之间的交互程度方面。ACID 特性的遵循度,决定了本事务在怎 样的程度下保证自身的未提交更改不受访问同一块信息的其他事务的影响。独立性是由一致 性和并发度共同决定的。在独立性级别提高时,一致性将会更好,但并发程度将降低。我们 将在第四章对“独立性”稍作更深入的讨论。

“持久化特性”的含义是,当我们收到了一个事务成功提交的信息,我们便能得到这个事务完 成的保证了,同时系统对数据库或 JMS 对象产生了永久的更改,这样的更改不会因为系统 失败而丢失——无论是我们对服务器控制台泼啤酒,还是在服务器上玩网游造成的宕机。而 今很多主流数据库厂商采用的一些精巧的缓存策略有可能对修改的持久性造成问题,但基本 上来说,当我们收到提交成功的信息时,我们就能被确保我们的修改是恒久的而且不被丢失 了。

