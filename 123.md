**13. Transaction Management**

**13.1 Introduction to Spring Framework transaction management**

Comprehensive transaction support is among the most compelling reasons to use the Spring Framework. The Spring Framework provides a consistent abstraction for transaction management that delivers the following benefits:

* Consistent programming model across different transaction APIs such as Java Transaction API \(JTA\), JDBC, Hibernate, and Java Persistence API \(JPA\).
* Support for declarative transaction management.
* Simpler API for programmatic transaction management than complex transaction APIs such as JTA.
* Excellent integration with Spring’s data access abstractions.

The following sections describe the Spring Framework’s transaction value-adds and technologies. \(The chapter also includes discussions of best practices, application server integration, and solutions to common problems.\)

* Advantages of the Spring Framework’s transaction support model describes _why_ you would use the Spring Framework’s transaction abstraction instead of EJB Container-Managed Transactions \(CMT\) or choosing to drive local transactions through a proprietary API such as Hibernate.
* Understanding the Spring Framework transaction abstraction outlines the core classes and describes how to configure and obtain DataSource instances from a variety of sources.
* Synchronizing resources with transactions describes how the application code ensures that resources are created, reused, and cleaned up properly.
* Declarative transaction management describes support for declarative transaction management.
* Programmatic transaction management covers support for programmatic \(that is, explicitly coded\) transaction management.
* Transaction bound event describes how you could use application events within a transaction.

综合事务支持是使用Spring框架最引人注目的原因之一。Spring框架提供了一个一致的抽象的事务管理，它提供了以下好处：

* 一致的编程模型跨越不同的事务API如java事务API（JTA），JDBC，Hibernate，和java持久化API（JPA）。

* 支持声明性事务管理。

* 比复杂的编程式事务API如JTA更简单的编程式事务管理API。

* 与Spring的数据访问抽象更好的集成。


以下各节描述了Spring框架的事务的增值服务和技术。（本章还包括讨论最佳实践、应用服务器集成和常见问题的解决方案）。

* Spring框架的事务支持的模式描述你为什么会使用Spring的事务抽象管理事务代替EJB容器（CMT）或选择驱动本地事务通过一个专有的API，如Hibernate。

* 理解Spring事务抽象概述的核心类和描述如何配置和从各种来源获取DataSource实例

* 与事务同步的资源描述了应用程序代码如何确保创建的资源，重新使用和清理正确的资源

* 声明性事务管理描述了声明性事务管理的支持

* 编程事务管理涵盖了对编程（即显式编码）事务管理的支持。

* 事务绑定事件描述了如何在一个事务中使用应用程序事件。


**13.2 Advantages of the Spring Framework’s transaction support model**

Traditionally, Java EE developers have had two choices for transaction management: _global_ or _local_ transactions, both of which have profound limitations. Global and local transaction management is reviewed in the next two sections, followed by a discussion of how the Spring Framework’s transaction management support addresses the limitations of the global and local transaction models.

传统上，java EE开发者有两个事务管理的选择：全局或本地事务，都具有深刻的局限性。全局和本地事务管理在以下两节来审视，通讨论Spring框架的事务管理支持如何解决了全局和本地事务模型的局限性。

**13.2.1 Global transactions**

Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API to use \(partly due to its exception model\). Furthermore, a JTA UserTransaction normally needs to be sourced from JNDI, meaning that you _also_ need to use JNDI in order to use JTA. Obviously the use of global transactions would limit any potential reuse of application code, as JTA is normally only available in an application server environment.

Previously, the preferred way to use global transactions was via EJB _CMT_ \(_Container Managed Transaction_\): CMT is a form of _declarative transaction management_ \(as distinguished from _programmatic transaction management_\). EJB CMT removes the need for transaction-related JNDI lookups, although of course the use of EJB itself necessitates the use of JNDI. It removes most but not all of the need to write Java code to control transactions. The significant downside is that CMT is tied to JTA and an application server environment. Also, it is only available if one chooses to implement business logic in EJBs, or at least behind a transactional EJB facade. The negatives of EJB in general are so great that this is not an attractive proposition, especially in the face of compelling alternatives for declarative transaction management.

全局事务使您能够使用多个事务性资源，通常是关系数据库和消息队列。应用服务器通过JTA管理全球事务，这是一个繁琐的API的使用（部分是因为它的异常模型）。此外，一个JTA UserTransaction通常需要来自JNDI，意味着你还需要使用JNDI为了使用JTA。显然，使用全局事务限制任何应用代码的重用性，如JTA一般只在应用服务器环境中可用。

此前，使用全局事务的首选方式是通过EJB的CMT（容器管理的事务）：CMT是一种形式的声明式事务管理（区别于编程式事务管理）。EJB CMT不交易相关的JNDI查找的需要，当然，使用EJB本身需要使用JNDI。它消除了大多数但不是所有的需要写java代码来控制交易。重大的缺陷是CMT绑定在JTA和应用服务器环境。另外，如果你选择在EJBs实现业务逻辑，这是唯一可用的，或者至少处于一个事务的EJB Facade。在一般的EJB的底片是如此之大，这是不是一个有吸引力的命题，尤其是在声明式事务管理面临的令人信服的替代品。

**13.2.2 Local transactions**

Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources. For example, code that manages transactions using a JDBC connection cannot run within a global JTA transaction. Because the application server is not involved in transaction management, it cannot help ensure correctness across multiple resources. \(It is worth noting that most applications use a single transaction resource.\) Another downside is that local transactions are invasive to the programming model.

