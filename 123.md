**13. Transaction Management**

**13.1 Introduction to Spring Framework transaction management**

Comprehensive transaction support is among the most compelling reasons to use the Spring Framework. The Spring Framework provides a consistent abstraction for transaction management that delivers the following benefits:

* Consistent programming model across different transaction APIs such as Java Transaction API \(JTA\), JDBC, Hibernate, and Java Persistence API \(JPA\).
* Support for declarative transaction management.
* Simpler API for programmatic transaction management than complex transaction APIs such as JTA.
* Excellent integration with Spring’s data access abstractions.

The following sections describe the Spring Framework’s transaction value-adds and technologies. \(The chapter also includes discussions of best practices, application server integration, and solutions to common problems.\)

* Advantages of the Spring Framework’s transaction support model describes _why_ you would use the Spring Framework’s transaction abstraction instead of EJB Container-Managed Transactions \(CMT\) or choosing to drive local transactions through a proprietary API such as Hibernate.
* Understanding the Spring Framework transaction abstraction outlines the core classes and describes how to configure and obtain DataSource instances from a variety of sources.
* Synchronizing resources with transactions describes how the application code ensures that resources are created, reused, and cleaned up properly.
* Declarative transaction management describes support for declarative transaction management.
* Programmatic transaction management covers support for programmatic \(that is, explicitly coded\) transaction management.
* Transaction bound event describes how you could use application events within a transaction.

综合事务支持是使用Spring框架最引人注目的原因之一。Spring框架提供了一个一致的抽象的事务管理，它提供了以下好处：

* 一致的编程模型跨越不同的事务API如java事务API（JTA），JDBC，Hibernate，和java持久化API（JPA）。

* 支持声明性事务管理。

* 比复杂的编程式事务API如JTA更简单的编程式事务管理API。

* 与Spring的数据访问抽象更好的集成。


以下各节描述了Spring框架的事务的增值服务和技术。（本章还包括讨论最佳实践、应用服务器集成和常见问题的解决方案）。

* Spring框架的事务支持的模式描述你为什么会使用Spring的事务抽象管理事务代替EJB容器（CMT）或选择驱动本地事务通过一个专有的API，如Hibernate。

* 理解Spring事务抽象概述的核心类和描述如何配置和从各种来源获取DataSource实例

* 与事务同步的资源描述了应用程序代码如何确保创建的资源，重新使用和清理正确的资源

* 声明性事务管理描述了声明性事务管理的支持

* 编程事务管理涵盖了对编程（即显式编码）事务管理的支持。

* 事务绑定事件描述了如何在一个事务中使用应用程序事件。


**13.2 Advantages of the Spring Framework’s transaction support model**

Traditionally, Java EE developers have had two choices for transaction management: _global_ or _local_ transactions, both of which have profound limitations. Global and local transaction management is reviewed in the next two sections, followed by a discussion of how the Spring Framework’s transaction management support addresses the limitations of the global and local transaction models.

传统上，java EE开发者有两个事务管理的选择：全局或本地事务，都具有深刻的局限性。全局和本地事务管理在以下两节来审视，通讨论Spring框架的事务管理支持如何解决了全局和本地事务模型的局限性。

**13.2.1 Global transactions**

Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API to use \(partly due to its exception model\). Furthermore, a JTA UserTransaction normally needs to be sourced from JNDI, meaning that you _also_ need to use JNDI in order to use JTA. Obviously the use of global transactions would limit any potential reuse of application code, as JTA is normally only available in an application server environment.

Previously, the preferred way to use global transactions was via EJB _CMT_ \(_Container Managed Transaction_\): CMT is a form of _declarative transaction management_ \(as distinguished from _programmatic transaction management_\). EJB CMT removes the need for transaction-related JNDI lookups, although of course the use of EJB itself necessitates the use of JNDI. It removes most but not all of the need to write Java code to control transactions. The significant downside is that CMT is tied to JTA and an application server environment. Also, it is only available if one chooses to implement business logic in EJBs, or at least behind a transactional EJB facade. The negatives of EJB in general are so great that this is not an attractive proposition, especially in the face of compelling alternatives for declarative transaction management.

全局事务使您能够使用多个事务性资源，通常是关系数据库和消息队列。应用服务器通过JTA管理全球事务，这是一个繁琐的API的使用（部分是因为它的异常模型）。此外，一个JTA UserTransaction通常需要来自JNDI，意味着你还需要使用JNDI为了使用JTA。显然，使用全局事务限制任何应用代码的重用性，如JTA一般只在应用服务器环境中可用。

此前，使用全局事务的首选方式是通过EJB的CMT（容器管理的事务）：CMT是一种形式的声明式事务管理（区别于编程式事务管理）。EJB CMT移除相关的JNDI查找的需要，当然，使用EJB本身需要使用JNDI。它消除了大多数但不是所有的需要写java代码来控制事务。重大的缺陷是CMT绑定在JTA和应用服务器环境。另外，如果你选择在EJBs实现业务逻辑，这是唯一可用的，或者至少处于一个事务的EJB Facade。总的来说EJB的负面影响是如此之大，这是不是一个有吸引力的命题，尤其是在声明式事务管理面临的令人信服的选择。

**13.2.2 Local transactions**

Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources. For example, code that manages transactions using a JDBC connection cannot run within a global JTA transaction. Because the application server is not involved in transaction management, it cannot help ensure correctness across multiple resources. \(It is worth noting that most applications use a single transaction resource.\) Another downside is that local transactions are invasive to the programming model.

另一个缺点是，本地事务是对编程模型的侵入性的

**13.2.3 Spring Framework’s consistent programming model**

Spring resolves the disadvantages of global and local transactions. It enables application developers to use a _consistent_ programming model _in any environment_. You write your code once, and it can benefit from different transaction management strategies in different environments. The Spring Framework provides both declarative and programmatic transaction management. Most users prefer declarative transaction management, which is recommended in most cases.

With programmatic transaction management, developers work with the Spring Framework transaction abstraction, which can run over any underlying transaction infrastructure. With the preferred declarative model, developers typically write little or no code related to transaction management, and hence do not depend on the Spring Framework transaction API, or any other transaction API.

Spring解决了全局和本地事务的缺点。它使应用程序开发人员可以在任何环境中使用一个一致的编程模型。你写你的代码一次，它可以受益于在不同的环境中的不同的事务管理策略。该框架提供了声明式和编程式事务管理。大多数用户更喜欢声明式的事务管理，在大多数情况下，这是推荐的。

与编程式事务管理，开发人员工作在Spring框架事务抽象之上，它可以运行在任何潜在的事务基础设施。使用首选的声明式模型，开发人员通常很少写或没有相关的事务管理的代码，因此不依赖于Spring框架事务接口，或任何其他应用程序的事务接口。

_**Do you need an application server for transaction management?**_

_The Spring Framework’s transaction management support changes traditional rules as to when an enterprise Java application requires an application server._

_In particular, you do not need an application server simply for declarative transactions through EJBs. In fact, even if your application server has powerful JTA capabilities, you may decide that the Spring Framework’s declarative transactions offer more power and a more productive programming model than EJB CMT._

_Typically you need an application server’s JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. Many high-end applications use a single, highly scalable database \(such as Oracle RAC\) instead. Standalone transaction managers such as _[****_Atomikos Transactions_****](http://www.atomikos.com/)_ and _[****_JOTM_****](http://jotm.objectweb.org/)_ are other options. Of course, you may need other application server capabilities such as Java Message Service \(JMS\) and Java EE Connector Architecture \(JCA\)._

_The Spring Framework gives you the choice of when to scale your application to a fully loaded application server. Gone are the days when the only alternative to using EJB CMT or JTA was to write code with local transactions such as those on JDBC connections, and face a hefty rework if you need that code to run within global, container-managed transactions. With the Spring Framework, only some of the bean definitions in your configuration file, rather than your code, need to change._

Spring的事务管理支持，改变了企业java应用需要应用服务器的传统的规则。

特别是，你不需要一个应用服务器是通过EJB的声明式事务。事实上，即使你的应用服务器具有强大的JTA功能，您可能会决定，Spring的声明式事务提供比EJB CMT更有力更高效的编程模型。

通常你需要应用服务器的JTA功能只有当您的应用程序需要处理的事务跨越多个资源，这是一个不为许多应用要求。许多高端应用中使用一个单一的，高度可扩展的数据库（如Oracle RAC）代替。独立的事务管理器如atomikos交易和JOTM等都是不错的选择。当然，你可能需要应用服务器的其他功能，如java消息服务（JMS）和java EE连接器架构（JCA）。

该框架为您提供何时将应用程序扩展到一个完全加载的应用程序服务器的选择。使用EJB CMT或JTA唯一的选择已经一去不复返了，那个时候通过写代码连接本地的事务如JDBC，面临容器管理的事务的代码的大量的返工，。随着_Spring_框架，只需要在你的配置文件中的一些bean定义需要改变，而不是你的代码。

**13.3 Understanding the Spring Framework transaction abstraction**

The key to the Spring transaction abstraction is the notion of a _transaction strategy_. A transaction strategy is defined by the org.springframework.transaction.PlatformTransactionManager interface:

Spring事务抽象的关键是事务策略的概念

